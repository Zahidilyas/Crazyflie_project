#!/usr/bin/env python

import sys
import math
import json

import rospy
import tf2_ros 
import tf2_geometry_msgs
from tf.transformations import quaternion_from_euler
from tf.transformations import euler_from_quaternion
from geometry_msgs.msg import TransformStamped, Vector3, PoseStamped
from aruco_msgs.msg import MarkerArray
from crazyflie_driver.msg import Position

# Current goal (global state)
goal = None

def goal_callback(msg):
    global goal

    goal = PoseStamped()
    goal.header.frame_id = msg.header.frame_id
    goal.pose.position = msg.markers[0].pose.pose.position 
    goal.pose.orientation = msg.markers[0].pose.pose.orientation

def publish_cmd(trans):
   
    Position_a = [trans.pose.position.x, trans.pose.position.y, trans.pose.position.z]
    Orientation_a = [trans.pose.orientation.x, trans.pose.orientation.y, trans.pose.orientation.z]
        
    # print(Position_a)
    t = TransformStamped()
    t.header.frame_id = trans.header.frame_id
    t.child_frame_id = 'aruco/detected' + str(0)
    t.transform.translation = Vector3(*Position_a)
    roll, pitch, yaw = Orientation_a
    (t.transform.rotation.x,
    t.transform.rotation.y,
    t.transform.rotation.z,
    t.transform.rotation.w) = quaternion_from_euler(math.radians(roll),
                                                    math.radians(pitch),
                                                    math.radians(yaw))

    # Publish these transforms statically forever
    broadcaster = tf2_ros.StaticTransformBroadcaster()
    broadcaster.sendTransform(t)

    # # Need to tell TF that the goal was just generated
    # goal.header.stamp = rospy.Time.now()

    # # rospy.loginfo('New goal')
    # #If TF cannot find a chain of transforms
    # if not tf_buf.can_transform(goal.header.frame_id, 'cf1/odom', goal.header.stamp):
    #     rospy.logwarn_throttle(5.0, 'No transform from %s to cf1/odom' % goal.header.frame_id)
    #     return
    
    # goal_odom = tf_buf.transform(goal, 'map')
    # print("hello world")
    # rospy.loginfo('New goal received:\n%s', goal_odom.pose.position.x)
    # return aruco_tdec

rospy.init_node('arucoframe')
#Subscribe to aruco marker topic
sub_goal = rospy.Subscriber('/aruco/markers', MarkerArray, goal_callback)
tf_buf   = tf2_ros.Buffer()
tf_lstn  = tf2_ros.TransformListener(tf_buf)

def main():

    rate = rospy.Rate(10)  # Hz
    while not rospy.is_shutdown():
        if goal:
            try:
                trans = tf_buf.transform(goal, 'map')
            except (tf2_ros.LookupException, tf2_ros.ConnectivityException, tf2_ros.ExtrapolationException):
                rate.sleep()
                continue
            # print(goal)

            publish_cmd(trans)
            # msg = 
            # for ind in range(len(msg.markers)):
            #     Position_a = [msg.markers[ind].pose.pose.position.x, msg.markers[ind].pose.pose.position.y, msg.markers[ind].pose.pose.position.z]
            #     Orientation_a = [msg.markers[ind].pose.pose.orientation.x, msg.markers[ind].pose.pose.orientation.y, msg.markers[ind].pose.pose.orientation.z]
            #     # rospy.loginfo('Message received:\n%s',Orientation_a)
            #     # msg.header.frame_id
            #     # msg.markers[ind].id
            #     # msg.markers[ind].pose.pose.position 
            #     # msg.markers[ind].pose.pose.orientation
                
            #     t = TransformStamped()
            #     t.header.frame_id = msg.header.frame_id
            #     t.child_frame_id = 'aruco/detected' + str(msg.markers[ind].id)
            #     t.transform.translation = Vector3(*Position_a)
            #     roll, pitch, yaw = Orientation_a
            #     (t.transform.rotation.x,
            #     t.transform.rotation.y,
            #     t.transform.rotation.z,
            #     t.transform.rotation.w) = quaternion_from_euler(math.radians(roll),
            #                                                     math.radians(pitch),
            #                                                     math.radians(yaw))

            #     # Publish these transforms statically forever
            #     broadcaster = tf2_ros.StaticTransformBroadcaster()
            #     broadcaster.sendTransform(t)
        rate.sleep()

if __name__ == "__main__":
    main()
